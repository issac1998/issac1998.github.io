---
title:  "Go:sema "
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-07-01T03:06:00-05:00
---

// Semaphore implementation exposed to Go.
// Intended use is provide a sleep and wakeup
// primitive that can be used in the contended case
// of other synchronization primitives.
// Thus it targets the same goal as Linux's futex,
// but it has much simpler semantics.
//
// That is, don't think of these as semaphores.
// Think of them as a way to implement sleep and wakeup
// such that every sleep is paired with a single wakeup,
// even if, due to races, the wakeup happens before the sleep.

Sema管理的Addr是一个uint32的地址，外部通过初始化uint值来决定能获取Sema的goroutine数量，例如STW中的worldsema初始化为1，代表同时只能有一个goroutine STW.管理过程十分简单，核心为semacquire 以及semrelease两个函数，作用为Sleep和wake。

SemaAcquire

1.首先尝试进行 CAS操作，将Addr的值-1。若Addr已经为0，说明需要将其加入等待队列

   加入等待队列流程：首先通过AcquireSudoG获取sudog对象，每个P以及全局都有sudog缓存以减少锁竞争，若两者都没有，则新建一个sudoG对象。


  // sudog (pseudo-g) represents a g in a wait list, such  as for sending/receiving
// on a channel.

// sudog is necessary because the g ↔ synchronization object relation
// is many-to-many. A g can be on many wait lists, so there may be
// many sudogs for one g; and many gs may be waiting on the same
// synchronization object, so there may be many sudogs for one object.

   获取SudoG时需要acquireM，防止垃圾回收引发的Semaphore循环被调用情况

   // Delicate dance: the semaphore implementation calls
	// acquireSudog, acquireSudog calls new(sudog),
	// new calls malloc, malloc can call the garbage collector,
	// and the garbage collector calls the semaphore implementation
	// in stopTheWorld.
	// Break the cycle by doing acquirem/releasem around new(sudog).
	// The acquirem/releasem increments m.locks during new(sudog),
	// which keeps the garbage collector from being invoked.


2.通过addr找到root，对root.Lock加锁，root.nwait.Add(1) to
 to disable "easy case" in semrelease。
 
 3.再次尝试CAS操作以防止错过WakeUp

 4.调用	root.queue(addr, s, lifo)将sudog入队等待，并调用goparkunlock( Puts the current goroutine into a waiting state , The goroutine can be made runnable again by calling goready(gp).)直到被semrelease唤醒，唤醒后执行releaseSudoG将sudog放回cache并releasem

SemaRelease


release的流程比较简单，大致逻辑是addr值+1，检查是否有nwait（因为在acquire加入nwait时有Addr的Case判断，所以如果这里没有nwait，那之后也不会有nwait），出队获取SudoG，减少nwait。调用readywithTime将G的状态改为Runnable并调用runqput放入放入local P的runNext，紧接着调用wakeP，等待下一次Schdule调度。

这里注意如果是handoff模式且cansemacquire，则调用goyield，goyield会立即运行停止运行当前G，并通过Schedule()运行正在等待的G，新g会继承老g的时间片防止一个semaphore hog P 太久。

上面提到的入队和出队都是基于treap结构体的，treap是BST tree和heap的结合，符合中序遍历有序的同时，父节点的优先级(ticket)小于等于子节点。ticket的作用是随机平衡，防止像BST一样退化成O(n)列表，但因需要减少了插入删除时的时间复杂度，并不期望像AVL一样完全平衡，因此只需要进行两种旋转操作。

入队：

LIFO 模式（特殊情况）：
// 在 Mutex 的饥饿模式下使用
queueLifo := waitStartTime != 0  // 已经等待过的 goroutine
runtime_SemacquireMutex(&m.sema, queueLifo, 2)


LIFO 模式（后进先出）：

将新的 sudog 替换树中现有节点的位置
保持原节点的 acquiretime（获取时间）作为最老的时间
将原节点添加到新节点的等待链表头部
FIFO 模式（先进先出）：

将新的 sudog 添加到现有节点的等待链表尾部

1. LIFO 重新排队
作用：给重新排队的 goroutine 优先级，避免无限期等待。







插入
给节点随机分配一个优先级，先和二叉搜索树的插入一样，先把要插入的点插入到一个叶子上，然后跟维护堆一样进行以下操作：

如果当前节点的优先级比父节点大就进行2. 或3. 的操作
如果当前节点是父节点的左子叶就右旋
如果当前节点是父节点的右子叶就左旋。
由于旋转是
O
(1)
{\displaystyle O(1)}的，最多进行h次（h是树的高度），插入的复杂度是
O
(
h
)
{\displaystyle O(h)}的，在期望情况下
h
=
O
(
log
⁡
n
)
{\displaystyle h=O(\log {n})}，所以它的期望复杂度是
O
(
log
⁡
n
)
{\displaystyle O(\log {n})}。

删除
因为Treap满足堆性质，所以只需要把要删除的节点旋转到叶节点上，然后直接删除就可以了。具体的方法就是每次找到优先级最大的子叶，向与其相反的方向旋转，直到那个节点被旋转到了叶节点，然后直接删除。

删除最多进行
O
(
h
)
{\displaystyle O(h)}次旋转，期望复杂度是
O
(
log
⁡
n
)
{\displaystyle O(\log {n})}。

查找
和一般的二叉搜索树一样，但是由于Treap的随机化结构，Treap中查找的期望复杂度是
O
(
log
⁡
n
)
{\displaystyle O(\log {n})}。


同时，Sema有许多性能考量，Copilot总结如下

1. 分片设计减少锁竞争
const semTabSize = 251  // 质数，避免哈希冲突

type semTable [semTabSize]struct {
    root semaRoot
    pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte
}

func (t *semTable) rootFor(addr *uint32) *semaRoot {
    return &t[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
}


性能考量：
251个分片：减少不同地址间的锁竞争
哈希分布：让不同地址分散到不同的 semaRoot

2. Treap O(log n) 的查找复杂度
3. 快速路径优化
公平性保证机制
1. LIFO 策略防止饥饿
公平性考量：
  已等待过的优先：避免某个 goroutine 无限期等待
  保持历史信息：s.acquiretime = t.acquiretime 保留最早的等待时间
2. 直接切换机制
  避免竞争：被唤醒的 goroutine 直接获得执行机会
  减少延迟：不经过调度器队列，立即执行
3. 竞争检测与避免
性能与公平的平衡点
1. 两层等待结构
平衡效果：
    性能：不同地址间高效隔离
    公平：相同地址内按顺序唤醒
2. 随机优先级的"软公平"
设计智慧：
  不追求严格公平：避免复杂的平衡算法
  期望公平：随机性打破了潜在的偏见模式
  性能优先：简单的旋转操作
3. 条件性直接切换
精细平衡：

避免死锁：检查 m.locks == 0
性能考虑：只在饥饿模式下使用
公平保证：确保等待者得到及时响应

总结

性能优先：使用高效的数据结构和算法
基本公平：通过 LIFO 和直接切换防止明显的饥饿
自适应平衡：根据竞争情况动态调整策略
工程务实：不追求理论完美，而是实用效果
这种设计让 Go 的同步原语在保持高性能的同时，也能在高竞争场景下提供合理的公平性保证，是系统设计中实用主义的典型体现。
