---
title:  "Go:sema "
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-07-01T03:06:00-05:00
---

// Semaphore implementation exposed to Go.
// Intended use is provide a sleep and wakeup
// primitive that can be used in the contended case
// of other synchronization primitives.
// Thus it targets the same goal as Linux's futex,
// but it has much simpler semantics.
//
// That is, don't think of these as semaphores.
// Think of them as a way to implement sleep and wakeup
// such that every sleep is paired with a single wakeup,
// even if, due to races, the wakeup happens before the sleep.

Sema管理的Addr是一个uint32的地址，外部通过初始化uint值来决定能获取Sema的goroutine数量，例如STW中的worldsema初始化为1，代表同时只能有一个goroutine STW.管理过程十分简单，核心为semacquire 以及semrelease两个函数，作用为Sleep和wake。

SemaAcquire

1.首先尝试进行 CAS操作，将Addr的值-1。若Addr已经为0，说明需要将其加入等待队列

   加入等待队列流程：首先通过AcquireSudoG获取sudog对象，每个P以及全局都有sudog缓存以减少锁竞争，若两者都没有，则新建一个sudoG对象

  // sudog (pseudo-g) represents a g in a wait list, such  as for sending/receiving
// on a channel.

// sudog is necessary because the g ↔ synchronization object relation
// is many-to-many. A g can be on many wait lists, so there may be
// many sudogs for one g; and many gs may be waiting on the same
// synchronization object, so there may be many sudogs for one object.

2.通过addr找到root，对root.Lock加锁，root.nwait.Add(1) to
 to disable "easy case" in semrelease。
 
 3.再次尝试CAS操作以防止错过WakeUp

 4.调用	root.queue(addr, s, lifo)将sudog入队等待，并调用goparkunlock( Puts the current goroutine into a waiting state , The goroutine can be made runnable again by calling goready(gp).)直到被semrelease唤醒，唤醒后执行releaseSudoG将sudog放回cache并releasem

SemaRelease


入队：

LIFO 模式（特殊情况）：
// 在 Mutex 的饥饿模式下使用
queueLifo := waitStartTime != 0  // 已经等待过的 goroutine
runtime_SemacquireMutex(&m.sema, queueLifo, 2)



