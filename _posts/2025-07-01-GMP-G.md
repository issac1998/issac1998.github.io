---
title:  "GMP: Overview And G "
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-07-01T03:06:00-05:00
---
GMP是GO的核心，之前看了很多笔记，也简单看过几次代码，但过段时间就忘了。这次自己写一份笔记，希望能增强记忆。

这篇文章先记录GMP的整体结构，以及G的具体实现。

G是用户协程，保存运行函数指针、栈、上下文。M是内核线程，具体执行任务。P则是逻辑处理器，负责管控资源（？），即使没有P，M也能通过加锁获取G（早期Go也是这么做的）或是直接运行在M（sysmon协程），P的目的只是为了管控资源。


G分为四类
1.执行Main函数的协程（）
2.用户协程
3.G0，每个M都有一个G0，主要用于执行调度逻辑的代码，不能抢占、不会被调度、放在系统栈上
4.sysmon协程，不需要P

一些重要字段如下：

G会维护一个Stack，记录真实栈的地址。stackguard0记录是否要进行抢占，stackguard1记录是否要进行栈增长

G0和Gsignal(什么用？)

m记录G绑定的m
sched记录gobuf，详细定义如后文
param记录指针参数，四种使用方式如comment所示
goid        goroutine唯一id

preempt标识是否允许被抢占

asyncSafePoint 异步安全点？在哪会用到啊



G的状态:
	// Beyond indicating the general state of a G, the G status
	// acts like a lock on the goroutine's stack (and hence its
	// ability to execute user code).
  不是很理解上面这段话

  	// _Gscanrunning is different: it is used to briefly block
	// state transitions while GC signals the G to scan its own
	// stack. This is otherwise like _Grunning.
	//


G的创建(用户协程)流程  

1.传入待执行函数fn， newproc 获取当前g和pc
2.systemstack切换至G0栈，执行newproc1

```
 // If systemstack is called from the per-OS-thread (g0) stack, or
// if systemstack is called from the signal handling (gsignal) stack,
// systemstack calls fn directly and returns.
// Otherwise, systemstack is being called from the limited stack
// of an ordinary goroutine
```


必须在系统栈（g0栈）上运行，以避免在分配过程中发生栈增长造成死锁。

这句话怎么理解？



```go
type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the //go:systemstack stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic    *_panic // innermost panic - offset known to liblink
	_defer    *_defer // innermost defer
	m         *m      // current m; offset known to arm liblink
	sched     gobuf
	syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc
	syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc
	stktopsp  uintptr // expected sp at top of stack, to check in traceback
	// param is a generic pointer parameter field used to pass
	// values in particular contexts where other storage for the
	// parameter would be difficult to find. It is currently used
	// in four ways:
	// 1. When a channel operation wakes up a blocked goroutine, it sets param to
	//    point to the sudog of the completed blocking operation.
	// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed
	//    the GC cycle. It is unsafe to do so in any other way, because the goroutine's
	//    stack may have moved in the meantime.
	// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a
	//    closure in the runtime is forbidden.
	// 4. When a panic is recovered and control returns to the respective frame,
	//    param may point to a savedOpenDeferState.
	param        unsafe.Pointer
	atomicstatus atomic.Uint32
	stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid         uint64
	schedlink    guintptr
	waitsince    int64      // approx time when the g become blocked
	waitreason   waitReason // if status==Gwaiting

	preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt
	preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule
	preemptShrink bool // shrink stack at synchronous safe point

	// asyncSafePoint is set if g is stopped at an asynchronous
	// safe point. This means there are frames on the stack
	// without precise pointer information.
	asyncSafePoint bool

	paniconfault bool // panic (instead of crash) on unexpected fault address
	gcscandone   bool // g has scanned stack; protected by _Gscan bit in status
	throwsplit   bool // must not split stack
	// activeStackChans indicates that there are unlocked channels
	// pointing into this goroutine's stack. If true, stack
	// copying needs to acquire channel locks to protect these
	// areas of the stack.
	activeStackChans bool
	// parkingOnChan indicates that the goroutine is about to
	// park on a chansend or chanrecv. Used to signal an unsafe point
	// for stack shrinking.
	parkingOnChan atomic.Bool
	// inMarkAssist indicates whether the goroutine is in mark assist.
	// Used by the execution tracer.
	inMarkAssist bool
	coroexit     bool // argument to coroswitch_m

	raceignore    int8  // ignore race detection events
	nocgocallback bool  // whether disable callback from C
	tracking      bool  // whether we're tracking this G for sched latency statistics
	trackingSeq   uint8 // used to decide whether to track this G
	trackingStamp int64 // timestamp of when the G last started being tracked
	runnableTime  int64 // the amount of time spent runnable, cleared when running, only used when tracking
	lockedm       muintptr
	sig           uint32
	writebuf      []byte
	sigcode0      uintptr
	sigcode1      uintptr
	sigpc         uintptr
	parentGoid    uint64          // goid of goroutine that created this goroutine
	gopc          uintptr         // pc of go statement that created this goroutine
	ancestors     *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
	startpc       uintptr         // pc of goroutine function
	racectx       uintptr
	waiting       *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
	cgoCtxt       []uintptr      // cgo traceback context
	labels        unsafe.Pointer // profiler labels
	timer         *timer         // cached timer for time.Sleep
	selectDone    atomic.Uint32  // are we participating in a select and did someone win the race?

	coroarg *coro // argument during coroutine transfers

	// goroutineProfiled indicates the status of this goroutine's stack for the
	// current in-progress goroutine profile
	goroutineProfiled goroutineProfileStateHolder

	// Per-G tracer state.
	trace gTraceState

	// Per-G GC state

	// gcAssistBytes is this G's GC assist credit in terms of
	// bytes allocated. If this is positive, then the G has credit
	// to allocate gcAssistBytes bytes without assisting. If this
	// is negative, then the G must correct this by performing
	// scan work. We track this in bytes to make it fast to update
	// and check for debt in the malloc hot path. The assist ratio
	// determines how this corresponds to scan work debt.
	gcAssistBytes int64
}
```

```go
type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	//
	// ctxt is unusual with respect to GC: it may be a
	// heap-allocated funcval, so GC needs to track it, but it
	// needs to be set and cleared from assembly, where it's
	// difficult to have write barriers. However, ctxt is really a
	// saved, live register, and we only ever exchange it between
	// the real register and the gobuf. Hence, we treat it as a
	// root during stack scanning, which means assembly that saves
	// and restores it doesn't need write barriers. It's still
	// typed as a pointer so that any other writes from Go get
	// write barriers.
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer
	ret  uintptr
	lr   uintptr
	bp   uintptr // for framepointer-enabled architectures
}
```

```go
	// _Gidle means this goroutine was just allocated and has not
	// yet been initialized.
	_Gidle = iota // 0

	// _Grunnable means this goroutine is on a run queue. It is
	// not currently executing user code. The stack is not owned.
	_Grunnable // 1

	// _Grunning means this goroutine may execute user code. The
	// stack is owned by this goroutine. It is not on a run queue.
	// It is assigned an M and a P (g.m and g.m.p are valid).
	_Grunning // 2

	// _Gsyscall means this goroutine is executing a system call.
	// It is not executing user code. The stack is owned by this
	// goroutine. It is not on a run queue. It is assigned an M.
	_Gsyscall // 3

	// _Gwaiting means this goroutine is blocked in the runtime.
	// It is not executing user code. It is not on a run queue,
	// but should be recorded somewhere (e.g., a channel wait
	// queue) so it can be ready()d when necessary. The stack is
	// not owned *except* that a channel operation may read or
	// write parts of the stack under the appropriate channel
	// lock. Otherwise, it is not safe to access the stack after a
	// goroutine enters _Gwaiting (e.g., it may get moved).
	_Gwaiting // 4

	// _Gmoribund_unused is currently unused, but hardcoded in gdb
	// scripts.
	_Gmoribund_unused // 5

	// _Gdead means this goroutine is currently unused. It may be
	// just exited, on a free list, or just being initialized. It
	// is not executing user code. It may or may not have a stack
	// allocated. The G and its stack (if any) are owned by the M
	// that is exiting the G or that obtained the G from the free
	// list.
	_Gdead // 6

	// _Genqueue_unused is currently unused.
	_Genqueue_unused // 7

	// _Gcopystack means this goroutine's stack is being moved. It
	// is not executing user code and is not on a run queue. The
	// stack is owned by the goroutine that put it in _Gcopystack.
	_Gcopystack // 8

	// _Gpreempted means this goroutine stopped itself for a
	// suspendG preemption. It is like _Gwaiting, but nothing is
	// yet responsible for ready()ing it. Some suspendG must CAS
	// the status to _Gwaiting to take responsibility for
	// ready()ing this G.
	_Gpreempted // 9

	// _Gscan combined with one of the above states other than
	// _Grunning indicates that GC is scanning the stack. The
	// goroutine is not executing user code and the stack is owned
	// by the goroutine that set the _Gscan bit.
	//
	// _Gscanrunning is different: it is used to briefly block
	// state transitions while GC signals the G to scan its own
	// stack. This is otherwise like _Grunning.
	//
	// atomicstatus&~Gscan gives the state the goroutine will
	// return to when the scan completes.
	_Gscan          = 0x1000
	_Gscanrunnable  = _Gscan + _Grunnable  // 0x1001
	_Gscanrunning   = _Gscan + _Grunning   // 0x1002
	_Gscansyscall   = _Gscan + _Gsyscall   // 0x1003
	_Gscanwaiting   = _Gscan + _Gwaiting   // 0x1004
	_Gscanpreempted = _Gscan + _Gpreempted // 0x1009
```
3.newproc1 
获取当前G的M和P，防止被preempt
 a.尝试从当前G对应的P或全局gFree列表中找g（复用gfree列表中已经分配但不再使用的G，查看大小是否合适，若不合适，调用stackfree释放旧栈 （还需要看看gfree列表怎么管理，gfget，gfput分别干了什么））
 
 b.若找不到，创建新g:malg分配栈空间（这里只分配内存空间，例如设置stackguard，stack.hi,stakc.lo，空间分配：小栈从当前P或全局cache中分配，如果栈比较大，会在全局大cache或heap上新建），设置状态为gdead（目的是不让GC scan），将g放入全局G列表。


 High Address (newg.stack.hi)
+---------------------------+
|                           |
|      Available Stack     |
|         Space             |
|                           |
+---------------------------+ <- newg.stackguard0 = newg.stack.lo + stackGuard
|      Stack Guard          |
|      (Red Zone)           |
+---------------------------+ <- newg.stack.lo (cleared to 0)
Low Address

c.初始化栈帧（设置SP，初始化栈帧内容）

High Address (newg.stack.hi)
+---------------------------+
|                           |
|      未使用的栈空间        |
|                           |
+---------------------------+ <- sp (初始栈指针)
|     初始栈帧              |
|   (totalSize大小)         |
|   - 返回地址              |
|   - 参数空间              |
|   - LR寄存器值            |
+---------------------------+
|                           |
|      剩余栈空间           |
|                           |
+---------------------------+ <- stackguard0
|      Stack Guard          |
+---------------------------+ <- newg.stack.lo
Low Address
d.设置sched中sp,pc,g等信息
e.设置父goroutine，go的pc
f.设置pprod
g.分配goid，状态为runable
h.设置race检测
i.释放m

4.将G放入runnext中，如果本地队列满，把被替换的G和本地队列的一半放入全局队列，确保新建G是runnext（有sysmon进程的情况下）

5.wakeP唤醒P，利用空闲的P执行G。若当前没有自旋的M（都在忙），且有空闲的P，则调用startm启动一个M并设为自旋状态。notewakeup唤醒等待在note上的M，M会根据runnext runq，全局runq，其他p的runq的顺序找到待执行的G

startM调度某个M来运行P（若没有M则创建）。首先找到空闲P，通过mget从m的空闲队列中获取睡眠中的工作线程，调用notewakeup唤醒M。
notewakeup和notesleep对应，需要用futex系统调用进入内核来唤醒，

如果没有M，则需要调用newm创建M，以上部分后续在M章节详细介绍。
// May run with m.p==nil, so write barriers are not allowed.
什么意思？


4.GoPark
主动让出CPU时间片，由gc，mfinal,chan,netpoll.select,time,trace,sema调用
a.记录一些m的状态，g的waitreason，调用mcall(park_m)，切换至g0栈将G的状态改为waiting，清除g和m的联系。

b.若mp.waitunlock非空，也就是这个M是在等锁的，那么尝试是否现在已经能够解锁并继续运行，重新置为runabble，并直接调用execute（gp）执行。否则，进入schedule逻辑重新选G

5.GoReady
唤醒G，由timer，sema，chan，netpoll调用
切换至G0栈，调用acquirem（禁用preemeption），切换G为runnable，runqput放至队列，wakep

6.GoExit
结束G，运行所有defer。Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutine。

切到G0栈，state改为Gdead，调用gfput放回gfree列表。调用schedule进行下一轮调度

7.Gosched

让出处理器，其他goroutine运行。
切换到G0栈，从Grunning状态改为Grunaable，dropg，调用globrunqput放回全局队列，调用schedule进行下一轮调度

8.Goyield


// goyield is like Gosched, but it:
// - emits a GoPreempt trace event instead of a GoSched trace event
// - puts the current G on the runq of the current P instead of the globrunq


二、G的栈
用户协程因为将goexit作为协程栈栈底，所

Go 的运行时需要高效地调度上万个 goroutine。为了简单、快速地在不同栈之间切换，Go 避免寄存器传参，采用全栈传参模型。
	•	所有函数的参数和返回值都通过栈帧传递。
	•	栈帧的布局是编译期确定的，所以函数在执行时可以快速读取参数。


为什么go要把参数放在调用者栈中，并不使用寄存器？

  1. 简化垃圾回收（GC）

Go 有一个并发的垃圾回收器，GC 需要知道所有指针的位置。
	•	把参数放在调用者栈帧里，可以更容易静态分析栈上哪些位置是指针，哪些不是。
	•	如果参数都放到寄存器或者由被调用者复制，GC 难以跟踪哪些寄存器/栈位置存了指针，尤其在调用链复杂时。

✅ 总结：让 GC 更高效、可靠。

⸻

2. 调用开销更可控、函数栈帧更小

如果参数放在被调用者栈帧中：
	•	每次函数调用都需要为参数重新开辟空间，复制一份，开销更大。
	•	而放在调用者里，调用多个函数时参数只需要一份。

Go 的调用开销被设计得非常轻量级，因为 goroutine 是极轻的协程（小栈空间、易切换），所以每个函数栈帧尽可能小，避免浪费空间。

✅ 总结：更轻量，适配 goroutine 的小栈模型。


分配栈逻辑；
1.小栈优先于mcache 分配
2\4\8\16 K分别有不同的fixed-size free-list allocator
如果对应大小的 stackcache 获取不到，那么调用 stackcacherefill ，stackcacherefill调用stackpooalloc从堆上申请一片内存空间填充到stackcache中。

例外情况： thisg.m.p == 0可能发生在系统调用 exitsyscall 或改变 P 的个数 procresize 时，thisg.m.preemptoff != ""会发生在 GC 的时候。也就是说在发生在系统调用 exitsyscall 或改变 P 的个数在变动，亦或是在 GC 的时候，调用stackpoolalloc从 stackpool 分配栈空间，否则从 mcache 中获取。


2.大栈从堆上分配，也是首先尝试从stackLarge.free分配，不行再调用allocManual从堆上分配内存


a. stackpoolalloc
 首先尝试从stackpool[order].item.span获取，如果不行，再调用allocManual分配。
  allocManual调用 allocspan，具体内容看内存分配（ https://www.luozhiyun.com/archives/434 ）

b.stackcacherefill 函数会调用 stackpoolalloc 从 stackpool 中获取一半的空间组装成 list 链表，然后放入到 stackcache 数组中。

可见，最终分配具体空间都是通过allocManul执行的，且执行完后都会调用OsStackAlloc initial这段空间

![a](/assets/images/Snipaste_2025-07-10_23-10-14.png)
