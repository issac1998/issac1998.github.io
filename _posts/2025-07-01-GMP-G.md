---
title:  "GMP: Overview And G "
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-07-01T03:06:00-05:00
---
GMP是Go的核心，之前看了很多笔记，也简单看过几次代码，但过段时间就忘了。这次自己写一份笔记，希望能增强记忆。

这篇文章先记录GMP的整体结构，以及G的具体实现。

# 介绍
间断来说，G是用户协程，保存运行函数指针、栈、上下文。M是内核线程，具体执行任务。P则是逻辑处理器，负责管控资源和优化缓存。
即使没有P，M也能通过加锁获取G（早期Go也是这么做的）或是直接运行在M上（sysmon协程），P的目的只是为了管控资源，例如P有G的本地队列用于无锁获取G，同时P的数量决定了同时有多少个M能运行。

# G

G分为四类
1.执行Main函数的协程
2.用户协程
3.G0，每个M都有一个G0，主要用于执行调度逻辑的代码，不能抢占、不会被调度、放在系统栈上
4.sysmon协程，不需要P
5.gsignal


G的重要结构如下：

G会维护一个Stack，记录真实栈的地址。stackguard0记录是否要进行抢占，stackguard1记录是否要进行栈增长
panic和defer链条
m记录G绑定的m
sched记录gobuf，标记G的sp, pc及上下文
param记录指针参数，四种使用方式如comment所示
goid        goroutine唯一id

preempt标识是否允许被抢占

asyncSafePoint 异步安全点，判断是否可以执行栈收缩

GCscandone标志G的stack是否被扫描完成
throwsplit标志stack不能增长


activeStackChans标识有Channel指向stack，在copy stack时需要 acquire channel locks 

ParkingonChan标识goroutine在park on一个chansend or chanrecv， Used to signal an unsafe point for stack shrinking
以上两点可以跟踪stack看看具体的应用


## G的状态
	// Beyond indicating the general state of a G, the G status
	// acts like a lock on the goroutine's stack (and hence its
	// ability to execute user code).
  不是很理解上面这段话

  	// _Gscanrunning is different: it is used to briefly block
	// state transitions while GC signals the G to scan its own
	// stack. This is otherwise like _Grunning.
	//


```go
	// _Gidle means this goroutine was just allocated and has not
	// yet been initialized.
	_Gidle = iota // 0

	// _Grunnable means this goroutine is on a run queue. It is
	// not currently executing user code. The stack is not owned.
	_Grunnable // 1

	// _Grunning means this goroutine may execute user code. The
	// stack is owned by this goroutine. It is not on a run queue.
	// It is assigned an M and a P (g.m and g.m.p are valid).
	_Grunning // 2

	// _Gsyscall means this goroutine is executing a system call.
	// It is not executing user code. The stack is owned by this
	// goroutine. It is not on a run queue. It is assigned an M.
	_Gsyscall // 3

	// _Gwaiting means this goroutine is blocked in the runtime.
	// It is not executing user code. It is not on a run queue,
	// but should be recorded somewhere (e.g., a channel wait
	// queue) so it can be ready()d when necessary. The stack is
	// not owned *except* that a channel operation may read or
	// write parts of the stack under the appropriate channel
	// lock. Otherwise, it is not safe to access the stack after a
	// goroutine enters _Gwaiting (e.g., it may get moved).
	_Gwaiting // 4

	// _Gmoribund_unused is currently unused, but hardcoded in gdb
	// scripts.
	_Gmoribund_unused // 5

	// _Gdead means this goroutine is currently unused. It may be
	// just exited, on a free list, or just being initialized. It
	// is not executing user code. It may or may not have a stack
	// allocated. The G and its stack (if any) are owned by the M
	// that is exiting the G or that obtained the G from the free
	// list.
	_Gdead // 6

	// _Genqueue_unused is currently unused.
	_Genqueue_unused // 7

	// _Gcopystack means this goroutine's stack is being moved. It
	// is not executing user code and is not on a run queue. The
	// stack is owned by the goroutine that put it in _Gcopystack.
	_Gcopystack // 8

	// _Gpreempted means this goroutine stopped itself for a
	// suspendG preemption. It is like _Gwaiting, but nothing is
	// yet responsible for ready()ing it. Some suspendG must CAS
	// the status to _Gwaiting to take responsibility for
	// ready()ing this G.
	_Gpreempted // 9

	// _Gscan combined with one of the above states other than
	// _Grunning indicates that GC is scanning the stack. The
	// goroutine is not executing user code and the stack is owned
	// by the goroutine that set the _Gscan bit.
	//
	// _Gscanrunning is different: it is used to briefly block
	// state transitions while GC signals the G to scan its own
	// stack. This is otherwise like _Grunning.
	//
	// atomicstatus&~Gscan gives the state the goroutine will
	// return to when the scan completes.
	_Gscan          = 0x1000
	_Gscanrunnable  = _Gscan + _Grunnable  // 0x1001
	_Gscanrunning   = _Gscan + _Grunning   // 0x1002
	_Gscansyscall   = _Gscan + _Gsyscall   // 0x1003
	_Gscanwaiting   = _Gscan + _Gwaiting   // 0x1004
	_Gscanpreempted = _Gscan + _Gpreempted // 0x1009
```

## G的创建(用户协程)流程  

1.传入待执行函数fn， newproc 获取当前g和pc
2.systemstack切换至G0栈，执行newproc1

必须在系统栈（g0栈）上运行，以避免在分配过程中发生栈增长造成死锁。

### newproc1  
新建一个G
获取当前G的M和P，防止被preempt
#### gfget
通过**gfget**尝试复用gfree列表中已经分配但不再使用的G,
 寻找顺序为，当前P的gFree，全局有栈的gFree(sched.gFree.Stack)，全局无栈的gFree(sched.gFree.noStack)
	若未持有栈空间，或初始栈的大小**startingStackSize**已经被GC改变（可以看栈的那一章），则重新分配一个**startingStackSize**的空间
#### malg
 b.若找不到，创建新g:malg分配一个n KB的栈空间（n的计算公式为stackSystem + stacksize，stacksize为2KB，stackSystem在不同平台不一样导致结果在不同平台有所差异。例如mac/Linux 上n 是2KB，Windows是8KB，因为windows没有独立的信号栈机制，使用异常处理（SEH - Structured Exception Handling）而不是Unix信号，异常处理直接在当前线程的栈上进行，需要在当前goroutine栈上预留空间来处理异常。而mac/Linux下有独立的信号栈，os会切换到专门的信号处理栈处理）

 这里只分配内存空间，例如设置stackguard，stack.hi,stakc.lo，空间分配：小栈从当前P或全局cache中分配，如果栈比较大，会在全局大cache或heap上新建），设置状态为gdead（目的是不让GC scan），将g放入全局G列表。

 分配栈空间大小


 High Address (newg.stack.hi)
+---------------------------+
|                           |
|      Available Stack     |
|         Space             |
|                           |
+---------------------------+ <- newg.stackguard0 = newg.stack.lo + stackGuard
|      Stack Guard          |
|      (Red Zone)           |
+---------------------------+ <- newg.stack.lo (cleared to 0)
Low Address

#### 后续操作
初始化栈帧（设置SP，初始化栈帧内容）

High Address (newg.stack.hi)
+---------------------------+
|                           |
|      未使用的栈空间        |
|                           |
+---------------------------+ <- sp (初始栈指针)
|     初始栈帧              |
|   (totalSize大小)         |
|   - 返回地址              |
|   - 参数空间              |
|   - LR寄存器值            |
+---------------------------+
|                           |
|      剩余栈空间           |
|                           |
+---------------------------+ <- stackguard0
|      Stack Guard          |
+---------------------------+ <- newg.stack.lo
Low Address

设置sched中sp,pc,g等信息
设置父goroutine，go的pc
分配goid，更改状态为runable
设置race检测
释放m

### runqput
runqput可根据传入值决定把G放到runnext中还是queue中
对于新建G流程，是将放入Runnext中

对于放入runnext的G：

获取当前P，将G放入runnext中，如果原先runnext有值，则将被替换的G放入本地队列，若队列满，则将被替换的G和本地队列的一半放入全局队列

对于放入queue的G：
将G放入本地队列，若队列满，则G和本地队列的一半放入全局队列


### wakeP

唤醒P，利用空闲的P执行G。若当前没有自旋的M（都在忙），且有空闲的P，则调用startm启动一个M并设为自旋状态。notewakeup唤醒等待在note上的M，M会根据runnext runq，全局runq，其他p的runq的顺序找到待执行的G

#### startM
调度某个M来运行P（若没有M则创建）。首先找到空闲P，通过mget从m的空闲队列中获取睡眠中的工作线程，调用notewakeup唤醒M。
notewakeup和notesleep对应，需要用futex系统调用进入内核来唤醒，

如果没有M，则需要调用newm创建M，以上部分后续在M章节详细介绍。
// May run with m.p==nil, so write barriers are not allowed.
什么意思？


4.GoPark
主动让出CPU时间片，由gc，mfinal,chan,netpoll.select,time,trace,sema调用
a.记录一些m的状态，g的waitreason，调用mcall(park_m)，切换至g0栈将G的状态改为waiting，清除g和m的联系。

b.若mp.waitunlock非空，也就是这个M是在等锁的，那么尝试是否现在已经能够解锁并继续运行，重新置为runabble，并直接调用execute（gp）执行。否则，进入schedule逻辑重新选G

5.GoReady
唤醒G，由timer，sema，chan，netpoll调用
切换至G0栈，调用acquirem（禁用preemeption），切换G为runnable，runqput放至队列，wakep

6.GoExit
结束G，运行所有defer。Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutine。

切到G0栈，state改为Gdead，调用gfput放回gfree列表。调用schedule进行下一轮调度

7.Gosched

让出处理器，其他goroutine运行。
切换到G0栈，从Grunning状态改为Grunaable，dropg，调用globrunqput放回全局队列，调用schedule进行下一轮调度

8.Goyield


// goyield is like Gosched, but it:
// - emits a GoPreempt trace event instead of a GoSched trace event
// - puts the current G on the runq of the current P instead of the globrunq


二、G的栈
用户协程因为将goexit作为协程栈栈底，所以当执行完协程任务函数时，会执行goexit函数


Go 的运行时需要高效地调度上万个 goroutine。为了简单、快速地在不同栈之间切换，Go 避免寄存器传参，采用全栈传参模型。
	•	所有函数的参数和返回值都通过栈帧传递。
	•	栈帧的布局是编译期确定的，所以函数在执行时可以快速读取参数。


为什么go要把参数放在调用者栈中，并不使用寄存器？

  1. 简化垃圾回收（GC）

Go 有一个并发的垃圾回收器，GC 需要知道所有指针的位置。
	•	把参数放在调用者栈帧里，可以更容易静态分析栈上哪些位置是指针，哪些不是。
	•	如果参数都放到寄存器或者由被调用者复制，GC 难以跟踪哪些寄存器/栈位置存了指针，尤其在调用链复杂时。

✅ 总结：让 GC 更高效、可靠。

⸻

2. 调用开销更可控、函数栈帧更小

如果参数放在被调用者栈帧中：
	•	每次函数调用都需要为参数重新开辟空间，复制一份，开销更大。
	•	而放在调用者里，调用多个函数时参数只需要一份。

Go 的调用开销被设计得非常轻量级，因为 goroutine 是极轻的协程（小栈空间、易切换），所以每个函数栈帧尽可能小，避免浪费空间。

✅ 总结：更轻量，适配 goroutine 的小栈模型。



![a](/assets/images/Snipaste_2025-07-10_23-10-14.png)
gFree.push(gp)将G放入p的gFree中
如果当前P已经有超过64个free的stack，则根据是否拥有stack放入全局的有栈(sched.gFree.Stack)或无栈(		sched.gFree.noStack)列表

GC时会清理有栈的G队列，放入无栈的队列。


在 go 程序运行时，会启动一个全局唯一的监控线程——sysmon thread，其负责定时执行监控工作(20us检查一次，如果50次检查都没有wakeup somebody，则double 检查周期，最长可至10ms），Always runs without a P, so write barriers are not allowed.，主要包括：

1.执行 netpoll 操作，唤醒 io 就绪的 g (如果10ms没有人poll过，之前释放M的时候也会netpoll)
2.执行 retake 操作，对运行时间过长的 g 或syscall的P执行抢占操作 
a.	// Preempt G if it's running on the same schedtick for
			// too long. This could be from a single long-running
			// goroutine or a sequence of goroutines run via
			// runnext, which share a single schedtick time slice.
b./ Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).
3.执行 gcTrigger 操作，探测是否需要发起新的 gc 轮次

 retake 方法本章研究的重点，其中根据抢占目标和状态的不同，又可以分为系统调用抢占和运行超时抢占.

5.2 系统调用
			// 若P是Syscall状态，Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).

首先需要先了解系统调用的逻辑：
系统调用是 m（thread）粒度的，在执行期间会导致整个 m 暂时不可用，所以此时的抢占处理思路是，将发起 syscall 的 g 和 m 绑定，但是解除 p 与 m 的绑定关系，使得此期间 p 存在和其他 m 结合的机会.

在发起系统调用时，会执行位于 runtime/proc.go 的 reentersyscall 方法，此方法核心步骤包括：

将 g 和 p 的状态更新为 syscall
解除 p 和 m 的绑定
将 p 设置为 m.oldp，保留 p 与 m 之间的弱联系（使得 m syscall 结束后，还有一次尝试复用 p 的机会）
当系统系统调用完成时，会执行位于 runtime/proc.go 的 exitsyscall 方法（此时执行方还是 m 上的 g），包含如下步骤：

检查 syscall 期间，p 是否未和其他 m 结合，如果是的话，直接复用 p，继续执行 g，否则通过 mcall 操作切换至 g0 执行 exitsyscall0 方法——尝试为当前 m 结合一个新的 p，如果结合成功，则继续执行 g，否则将 g 添加到 grq 后暂停 m

我们将视角切回到 sysmon thread 中的 retake 方法，此处会遍历每个 p，并针对正在发起系统调用的 p 执行如下检查逻辑：

检查 p 的 lrq 中是否存在等待执行的 g，检查head是否==tail，runnext是否为空，以上两个判断条件要通过指针赋值同时判断，防止判断过程中有G新加入
检查 p 的 syscall 时长是否 >= 10ms
但凡上述条件满足其一，更改P为Pdile，并执行handoffp——依次查看本地runq->traceWork->GC work(查看gcMarkWorkAvailable)->缺少spinning/idle M's-> 如果需要M，调用startM 分配一个新的 m 与 p 结合，完成后续任务的调度处理（这里还有些Sched逻辑，例如sched.gcwaiting等，还需要问问ai）

5.3 运行超时
除了系统调用抢占之外，当 sysmon thread 发现某个 g 执行时间过长时，也会对其发起抢占操作.

1）发起抢占
在 retake 方法中，会检测到哪些 p 中运行一个 g 的时长超过了 10 ms，	// Preempt G if it's running on the same schedtick for
			// too long. This could be from a single long-running
			// goroutine or a sequence of goroutines run via
			// runnext, which share a single schedtick time slice.然后对其发起抢占操作（preemtone）：

在 preemtone 方法中：
// This function is purely best-effort. It can incorrectly fail to inform the
// goroutine. It can inform the wrong goroutine. Even if it informs the
// correct goroutine, that goroutine might ignore the request if it is
// simultaneously executing newstack.
1.对目标 g 设置抢占标识（将 stackguard0 标识设置为 stackPreempt），这样当 g 运行到检查点时，就会配合抢占意图，自觉完成让渡操作
2.会对目标 g 所在的 m 发送抢占信号 sigPreempt，通过改写 g 程序计数器（pc，program counter）的方式将 g 逼停

在 preemptM 方法中，会通过 tkill 指令向进程中的指定 thread 发送抢占信号 sigPreempt，对应代码位于 runtime/signal_unix.go：

2）协作式抢占

对于运行中的 g，在栈空间不足时，会切换至 g0 调用 newstack 方法执行栈空间扩张操作，在该流程中预留了一个检查桩点，当其中发现 g 已经被打上抢占标记时，就会主动配合执行让渡操作：

这种通过预留检查点，由 g 主动配合抢占意图完成让渡操作的流程被称作协作式抢占，其存在的局限就在于，当 g 未发生栈扩张行为时，则没有触碰到检查点的机会，也就无法响应抢占意图.

3）非协作式抢占

为了弥补协作式抢占的不足，go 1.14 中引入了基于信号量实现的非协作式抢占机制.

在 go 程序启动时，main thread 会完成对各类信号量的监听注册，其中也包含了抢占信号 sigPreempt（index = 16）. 对应代码位于 runtime/signal_unix.go：
当某个 m 接收到抢占信号后，会由 gsignal 通过 sighandler 方法完成信号处理工作，此时针对抢占信号会进一步调用 doSigPreempt 方法：在判断 g 具备可抢占条件后，则会保存 g 的寄存器信息，然后修改 g 的栈程序计数器 pc 和栈顶指针 sp，往其中插入一段函数 asyncPreempt：

sigctxt.pushCall 方法中，通过移动栈顶指针（sp，stack pointer）、修改程序计数器（pc，program counter）的方式，强行在 g 的执行指令中插入了一段新的指令——asyncPreempt 函数.

由于 pc 被修改了，所以抢占的目标 g 随后会执行到 asyncPreemt2 方法，其中会通过 mcall 指令切换至 g0，并由 g0 执行 gopreempt_m ，完成 g 的让渡操作.


2025-07-25 14:14



4.1 结束让渡
当 g 执行结束时，会正常退出，并将执行权切换回到 g0.

首先，g 在运行结束时会调用 Goexit，执行所有defer，切换至 g0，并由 g0 执行下述步骤：

将 g 状态由 running 更新为 dead
清空 g 中的数据，更新GC统计值
dropg解除 g 和 m 的关系
gfput Put on gfree list
调用 schedule 方法发起新一轮调度

4.2 主动让渡
主动让渡指的是由用户手动调用 runtime.Gosched 方法让出 g 所持有的执行权. 在 Gosched 方法中，会通过 mcall 指令切换至 g0，并由 g0 执行 gosched_m 方法，其中包含如下步骤：

将 g 由 running 改为 runnable 状态
解除 g 和 m 的关系
将 g 直接添加到全局队列 grq 中
调用 schedule 方法发起新一轮调度
4.3 阻塞让渡 gopark
阻塞让渡指的是 g 在执行过程中所依赖的外部条件没有达成，需要进入阻塞等待的状态（waiting），直到条件达成后才能完成将状态重新更新为就绪态（runnable）.

Golang 针对 mutex、channel 等并发工具的设计，在底层都是采用了阻塞让渡的设计模式，具体执行的方法是位于 runtime/proc.go 的 gopark 方法：

通过 mcall 从 g 切换至 g0，并由 g0 执行 park_m 方法
g0 将 g 由 running 更新为 waiting 状态，然后发起新一轮调度。
在外部条件就绪时，通过 goready 操作将其更新为 runnable 状态并重新添加到就绪队列中。gopark后，等待findRunnable、goready等函数将目标 g 状态由 waiting 改为 runnable，并添加到goNext或就绪队列中，最后调用schdule执行G。

4.4 handoff 调用goyield，和gosched唯一区别是放到本地P的G队列
