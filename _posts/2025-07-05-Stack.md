---
title:  "GMP "
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-07-01T03:06:00-05:00
---
这篇文章介绍GO的栈管理，包含分配、扩容、缩容等逻辑，只会描述具体的栈操作函数，上层的调用不会展开介绍

分配栈逻辑；
1.小栈优先于mcache 分配
2\4\8\16 K分别有不同的fixed-size free-list allocator
如果对应大小的 stackcache 获取不到，那么调用 stackcacherefill ，stackcacherefill调用stackpooalloc从堆上申请一片内存空间填充到stackcache中。

例外情况： thisg.m.p == 0可能发生在系统调用 exitsyscall 或改变 P 的个数 procresize 时，thisg.m.preemptoff != ""会发生在 GC 的时候。也就是说在发生在系统调用 exitsyscall 或改变 P 的个数在变动，亦或是在 GC 的时候，调用stackpoolalloc从 stackpool 分配栈空间，否则从 mcache 中获取。


2.大栈从堆上分配，也是首先尝试从stackLarge.free分配，不行再调用allocManual从堆上分配内存


a. stackpoolalloc
 首先尝试从stackpool[order].item.span获取，如果不行，再调用allocManual分配。
  allocManual调用 allocspan，具体内容看内存分配（ https://www.luozhiyun.com/archives/434 ）

b.stackcacherefill 函数会调用 stackpoolalloc 从 stackpool 中获取一半的空间组装成 list 链表，然后放入到 stackcache 数组中。

可见，最终分配具体空间都是通过allocManul执行的，且执行完后都会调用OsStackAlloc initial这段空间

栈的新建
在newproc1时创建新g，以下节选自GMP一章中G的初始化流程
 b.若找不到，创建新g:malg调用stackalloc分配栈空间（这里只分配内存空间，例如设置stackguard，stack.hi,stakc.lo，空间分配：小栈从当前P或全局cache中分配，如果栈比较大，会在全局大cache或heap上新建），设置状态为gdead（目的是不让GC scan），将g放入全局G列表。


 High Address (newg.stack.hi)
+---------------------------+
|                           |
|      Available Stack     |
|         Space             |
|                           |
+---------------------------+ <- newg.stackguard0 = newg.stack.lo + stackGuard
|      Stack Guard          |
|      (Red Zone)           |
+---------------------------+ <- newg.stack.lo (cleared to 0)
Low Address

c.初始化栈帧（设置SP，初始化栈帧内容）

High Address (newg.stack.hi)
+---------------------------+
|                           |
|      未使用的栈空间        |
|                           |
+---------------------------+ <- sp (初始栈指针)
|     初始栈帧              |
|   (totalSize大小)         |
|   - 返回地址              |
|   - 参数空间              |
|   - LR寄存器值            |
+---------------------------+
|                           |
|      剩余栈空间           |
|                           |
+---------------------------+ <- stackguard0
|      Stack Guard          |
+---------------------------+ <- newg.stack.lo
Low Address
d.设置sched中sp,pc,g等信息
e.设置父goroutine，go的pc
f.设置pprod
g.分配goid，状态为runable
h.设置race检测
i.释放m

参数含义	
    // stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the //go:systemstack stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).

	stackGuard = stackNosplit + stackSystem + abi.StackSmall
    stackNosplit是Nosplit函数能够占用的最大空间，stackSystem是系统所占Stack。

	SP、PC类似操作系统SP、PC，但存在sched的gobuf里

栈增长

编译器会在函数的头部添加检查代码，检查是否需要增长

跳过检查：当函数处于调用链的叶子节点，且栈帧小于StackSmall字节时，则自动标记为NOSPLIT。另外有一些函数手动打上noSPLIT标签

检查：

1.对于frameSize小于stacksmall的分配，可以只检查SP<=stackguard0，若符合直接插入（因为stackGuard确保了有大于stacksmall的空间）（
堆栈分割检查后，SP 可以比堆栈保护低 StackSmall 个字节
），否则call morestack。

2.对于大于StackBig的frameSize，每次都call morestack。

3.对于stackSmall和StackBig之间的frameSize，按如下格式分配（StackBig的值保证了此时Sp-frameSize 和stackguard-stacksmall都不会underfflow）
比较stackguard < SP - frame Size+ StackSmall 则call morestack

增长：moreStack
morestack 设置morebuf保存G的sched信息，做完一些校验，会切换到 G0 调用 runtime·newstack来完成扩容的操作。


首先执行抢占逻辑，判断是否此G是否是需要被”抢占“的G，若是，则首先判断是否能抢占：
	// If we're holding locks, mallocing, or preemption is disabled, or P.status!=prunning ,don't preempt。
若不能抢占，把stackguard0设回 gp.stack.lo + stackGuard，并调用gogo恢复执行上下文并重新运行此G

若能抢占，判断gp.preemptShrink 调用shirinkstack，判断preemptStop执行preemptPark，最后调用gopreempt_m(gp) ，Act like goroutine called runtime.Gosched.

执行真正的moreStack逻辑

分配的空间大小：不断翻倍oldSize的值作为newSize，直到够用

特殊情况：stackguard0 ==stackForceMove ，Forced stack movement used for debug （还有除了preempt的用处！此外还有StackFork表示线程正在forking，不允许被split；stackPoisonMin表示低于此值时不允许被preempt和forceMove）
StackSmall默认值为128 B

更改G的状态为GcopyStack（防止GC扫描Stack），并执行copystack

CopyStack首先调用addScannableStack增加GCController的值，然后调用stackAlloc分配新栈空间

记录老栈的信息,并记录Delta=new.hi-old.hi。

1.调整SudoG中的指针

判断activeStackChans是否为true，因为Channel传递时有可能传递原栈上的参数，若有Chan在waiting，可能导致获取参数时参数地址已经失效了，因此需要，因此需要获取Channel的锁后再调取adjustSudogs。若不为True，可以直接调整adjustsudogs

adjustsudogs遍历g的SudoG列表，如果SudoG中的data element point to stack，则将其指针指向+delta位置.

2.调用memMove copy stack。
3.调整Ctxt，Ctxt可能（？）指向堆上分配的funcval，由GC追踪。等学完GC再回来看吧

4.调整Defers和panics

5.调整gp.Stack,gp.StackGuard0，Sched.s,gp.stktopSp等栈信息

6.将G上的栈引用切换成新栈

7.调用stackFree(old)清理旧栈


栈收缩
shrinkStack在两个地方被调用，
1.gc扫描scanStack时
2.newStack时，其实此时调用只是因为gc scanStack判断！isShrinkStackSafe时，shrink the stack at the next sync safe point.

shrinkStack 通过SP判断当前栈是否使用了>1/4,最终也是调用copyStack，但newSize被设置为oldsize/2

栈释放
待看源码
go函数结束后，会调用gfput根据栈大小放入不同的sched.gFree队列，若<2KB，放入有栈的gFRee队列，若>2KB，执行栈释放逻辑，放入无栈队列。
如果栈的大小是非标注你的

调用newproc时，先取有栈的队列，再取无栈的队列。

GC时会清理有栈的G队列，放入无栈的队列。

释放栈时，小于32kb的栈，先放回本地缓存mcache.stackcache. 若对应大小的本地缓存（例如4kb的cache）已经超出32KB，则将一部分放进全局缓存stackpoll
