---
title:  "GO内存管理"
search: true
categories:
  - Jekyll
  - Go
  - codes
  - src
last_modified_at: 2025-08-03T03:06:00-05:00
---
- [定义](#定义)
  - [mspan -Golang 内存管理的最小单元](#mspan--golang-内存管理的最小单元)
  - [mcache-每个P对小对象的缓存](#mcache-每个p对小对象的缓存)
  - [mcentral-每个mspanClass的list](#mcentral-每个mspanclass的list)
  - [fixalloc: a free-list allocator for fixed-size off-heap objects, used to manage storage used by the allocator.](#fixalloc-a-free-list-allocator-for-fixed-size-off-heap-objects-used-to-manage-storage-used-by-the-allocator)
  - [mheap: the malloc heap, managed at page (8192-byte) granularity.](#mheap-the-malloc-heap-managed-at-page-8192-byte-granularity)
  - [allocBits](#allocbits)
- [分配流程](#分配流程)
  - [分配内存空间流程](#分配内存空间流程)
- [重要结构体解释](#重要结构体解释)
  - [mheap](#mheap)
    - [mheap alloc流程](#mheap-alloc流程)
    - [heap.initSpan初始化span](#heapinitspan初始化span)
    - [更新一些stats。](#更新一些stats)
  - [heap.Grow](#heapgrow)
  - [heap.initSpan](#heapinitspan)
  - [heapArena](#heaparena)
- [疑问](#疑问)
  - [清除Span并free Object](#清除span并free-object)
  - [(小对象扫描的Noscan\\Noheaer 有什么区别呢？)](#小对象扫描的noscannoheaer-有什么区别呢)
  - [mem.go文件](#memgo文件)


# 定义
小于32KB的内存空间按照大小被分为大约70种class，每一种class都有自己的free set of objects，由bitmap管理

## mspan -Golang 内存管理的最小单元

mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样），mspan会根据存储的对象大小分为约70种class，同等级的mspan会通过链表链接，基于bitMap 辅助快速找到空闲内存块，每个bit代表一个object块。（怎么找，问问ai）
// An mspan is a run of pages.
//
// When a mspan is in the heap free treap, state == mSpanFree
// and heapmap(s->start) == span, heapmap(s->start+s->npages-1) == span.
// If the mspan is in the heap scav treap, then in addition to the
// above scavenged == true. scavenged == false in all other cases.
//
// When a mspan is allocated, state == mSpanInUse or mSpanManual
// and heapmap(i) == span for all s->start <= i < s->start+s->npages.

// Every mspan is in one doubly-linked list, either in the mheap's
// busy list or one of the mcentral's span lists.

// An mspan representing actual memory has state mSpanInUse,
// mSpanManual, or mSpanFree. Transitions between these states are
// constrained as follows:
//
//   - A span may transition from free to in-use or manual during any GC
//     phase.
//
//   - During sweeping (gcphase == _GCoff), a span may transition from
//     in-use to free (as a result of sweeping) or manual to free (as a
//     result of stacks being freed).
//
//   - During GC (gcphase != _GCoff), a span *must not* transition from
//     manual or in-use to free. Because concurrent GC may read a pointer
//     and then look up its span, the span state must be monotonic.
//
// Setting mspan.state to mSpanInUse or mSpanManual must be done
// atomically and only after all other span fields are valid.
// Likewise, if inspecting a span is contingent on it being
// mSpanInUse, the state should be loaded atomically and checked
// before depending on other fields. This allows the garbage collector
// to safely deal with potentially invalid pointers, since resolving
// such pointers may race with a span being allocated.

mspan中有字段freeIndex标记free的object，每次分配从这个值开始扫，直到遇到一个free object（If n >= freeindex and allocBits[n/8] & (1<<(n%8)) is 0，then object is free），然后更新freeIndex值

mspan有字段nelems标记span中的object值

mspan有字段freeIndexforScan，标记GC Scanner应该开始扫的位置。

mspan的allocBits和gcMarkbits ，是指向span's mark 和allocation bit的指针 。 /The sweep will free the old allocBits and set allocBits to the gcmarkBits. The gcmarkBits are replaced with a fresh zeroed out memory.

另外还有 sweep generation字段 
 // sweep generation:
 // if sweepgen == h->sweepgen - 2, the span needs sweeping
 // if sweepgen == h->sweepgen - 1, the span is currently being swept
 // if sweepgen == h->sweepgen, the span is swept and ready to use
 // if sweepgen == h->sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping
 // if sweepgen == h->sweepgen + 3, the span was swept and then cached and is still cached
 // h->sweepgen is incremented by 2 after every GC



## mcache-每个P对小对象的缓存
在alloc字段中缓存了不同spanClass的mspan链表，同时有tiny allocator的字段，用于处理小于 16B 对象的内存分配。



## mcentral-每个mspanClass的list
具体由 partial 和full 两个mspan set组成，分别代表已经清理的和未清理的span。每轮GC后partial和full会交换角色。Sweeping pops spans from the unswept set and pushes spans that are still in-use on the swept set. Likewise, allocating an in-use span pushes it on the swept set


## fixalloc: a free-list allocator for fixed-size off-heap objects, used to manage storage used by the allocator.
具体内存的分配都会走到fixalloc，可以详细看看

## mheap: the malloc heap, managed at page (8192-byte) granularity.
堆由一组arenas组成。每个arena是4M（32位）或64M（64位），由对应的、堆外分配的heapArena存储元数据，包含heap bitmap for all words以及span map for all pages。内存地址可以被看作是一系列arena帧。.The arena map (mheap_.arenas) maps from arena frame number to *heapArena, or nil for parts of the address space not backed by the Go heap

## allocBits

# 分配流程
## 分配内存空间流程
（1）从 P 专属 mcache 的 tiny 分配器取内存（无锁）

（2）根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）

（3）根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）

（4）根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）

（5）mheap 向操作系统申请内存(至少1MB)，更新页分配器的索引信息，然后重复（4）.
 
不同大小的对象会有不同的分配流程
对于微对象(小于16B)执行上述全部流程
对于小对象(小于32KB)执行上述流程的（2）-（5）步
对于大对象的分配流程执行上述流程的（4）-（5）步，直接操作mheap

###具体代码是在mallocGC中，mallocGC在分配前，需要判断是否assist GC（这块后续放GC讲），再进行真正的alloc信息。
根据不同大小，会调用不同函数分配
a)无指针，<16B mallocgcTiny
b)无指针，16B-32KB 调用mallocgcSmallNoscan
c) 如果 heapBitsInSpan(size)，调用mallocgcSmallScanNoHeader
d) !heapBitsInSpan(size)，调用mallocgcSmallScanHeader(Noscan\Noheaer 有什么区别呢？)
e)>32KB，调用mallocgcLarge
最后还需要调整GC assit debt（也放GC讲）

(1)Tiny allocator，结合several tiny request至同一个memory block(span)。分配新Tiny对象时，先尝试从P的Mcache中当前的tiny block分配: 调整tinyoffset，把当前block的空间返回。如果不够用，分配新的tiny block(Span)
(2）
a.获取mache中对应class大小的span，调用nextFreeFast尝试从allocCache中拿到所需Object。
 allocCache是freeIndex处的allocBits缓存
b.如果空间不够，则调用nextFree
      nextFree： returns the next free object from the cached span if one is available，并通过checkGCTrigger标记是否是heavy weight allocation，如果是则上层需要决定是否GC。如果从s.nextFreeIndex未拿到Object则会调用refill，从mcentral获取。
(3) mcentral 
refill：将当前cache的span通过uncacheSpan返回给central list，再从CacheSpan从 mcentral 拿一批新的（为什么要一批一批做，问问ai）。若cacheSpan失败，则调用grow从heap分配一批新空间
uncacheSpan:若sweepgen为heap.sweepGen+1，则调用sweep进行清理，否则仍有剩余空间放入central.partial，无剩余空间放入central.Full
cacheSpan: 
1.首先通过deductSweepCredit计算credit，如果不够，则调用sweepDone sweep一些unswept的heap，并把页还给heap。
sweepDone:从full或partial取出一个span，调用sweep清理页面，并调用mheap_.reclaimCredit.Add(npages)标记这些页可以被用于span alloc了。（sweep的具体逻辑需要用ai看看）
从full还是partial选是通过以下函数确定的，问问AI
// split returns the underlying span class as well as // whether we're interested in the full or partial // unswept lists for that class, indicated as a boolean // (true means "full"). func (s sweepClass) split() (spc spanClass, full bool) { return spanClass(s >> 1), s&1 == 0 }
(4)
grow: 调用mheap.alloc, allocates a new span of npage pages from the GC'd heap.具体可见mheap中逻辑
(5）mheap.alloc系统调用allocSpan，首先从cache拿，不行就调用spanalloc.alloc()生成一份（详情见mheap）

可以看到mallocSmall和malloctiny大致一样，最大不同是不从TinyAllcator分配空间了，其次根据有无指针分为了Noscan，根据heapbitsinspan分为了Noheader和header，这个需要问问ai。。

mallocLarge 先获取mcache，通过cache.allocLarge分配堆空间，流程大致相同，但最后一步时，如果需要scan，并且needzero，则调用memclrNoHeapPointersChunked先清理空间，这部分也需要结合AI看看。/
##清理空间&设置参数，
对于小对象，分配到对象后，如果needzero且mspan.needzero设为true，表示object 需要在分配时zero，就会立即调用memclrNoHeapPointers汇编clear n bytes statring at ptr

而对大对象，在releasem后，在malloc流程的最后才会执行清理逻辑，说是对象可以被zeroed late如果期间有抢占发生的话，结合ai看看）。如果含指针或needzero，会在设置调用memclrNoHeapPointersChunked 按chunk粒度反复调用memclrNoHeapPointers，调用Chunked的原因说是为了可以被抢占（为什么大对象需要被抢占，为什么小对象就不要考虑被抢占的问题呢？）

为什么小对象没有类似的清理span逻辑呢？

执行publicationBarrier，使初始化对garbage collect 可见（结合AI看看）


执行更改freeIndexForScan，gcmarknewobject，nextsample等一系列GC相关操作，并尝试gcstart，等GC再讲。



# 重要结构体解释
## mheap
mheap由一组arena组成，heapArena 是 mheap 向操作系统申请内存的单位
，每个 heapArena 包含 8192 个页，一个页8Kb，则大小为 8192 * 8KB = 64 MB

通过堆外分配的heapArena存储arena的元数据，heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.（ai看看）

mheap结构体中储存了三个重要信息：
1.通过Allspan记录所有mspan信息
2.通过central所有mcentral信息 
3.通过 arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena 二级页表记录heapArena

### mheap alloc流程
1.mheap alloc: allocates a new span of npage pages from the GC'd heap.
 如果不是所有span都被清理完成，需要reclaim清除并claim需要的size，之后切到systemstack执行allocSpan
 
2.heap.allocspan: 
需要先找到span，找到后进入haveSpan逻辑，初始化span
首先判断是否需要physical page aligned（看描述只有部分platform需要，问问ai）
找Span：
a.如果npage小于pageCache的1/4，尝试从page cache分配：先调用 c.alloc 从cache分配一段npages，返回基地址，再调用tryallocMspan从p的local cache分配mspan，有可能分配不到mspan，那么走下述逻辑
b.加heap锁
c.对于physical page aligned，先pages.find一个base地址，如果不够则通过heap.grow分配npage pages of memory to the heap，找到后调用pages.allocRange分配scav
d.对于非aligned的情况，调用h.pages.alloc 分配base和scav，如果不够也会调用heap.grow分配

####调用allocMSpanLocked分配mspan个对象，如果有P，从P的mspancache获取，不够则调用(*mspan)(h.spanalloc.alloc()) refill，如果没有P，直接调用(*mspan)(h.spanalloc.alloc())，最后会走到fixalloc的alloc界面（后续还要看看）
拿到Span:
由于上一步分配了一些scav，所以可能需要清理空间以满足memory limit和heap space limit，调用pages.scavenge来清理。
### heap.initSpan初始化span
### 更新一些stats。


## heap.Grow
## heap.initSpan
mpagealloc中有关于page分配的详细内容，例如find，heap.grow 可以结合ai看看
mgcscavenge里有诸如scavenge清理空间的内容，也需要结合ai看看

## heapArena
heapArena 的spans 字段 maps from 虚拟地址页ID to *mspan。
 -对于已分配的span，所有pages maps to span itselt
 -对于free span，只有最低和最高的pages map to the span itself，中间的pages map to an arbitrary span.
 -对于没有allocate的page，spans entries are nil.

heapArena 的pageInUse 字段 是一个bitmap，指明哪些span是在mspanInUse状态的，只有span的第一个页会被作为bitmap的索引值

pageMarks字段是一个bitmap，指明哪些span有marked object

pageSpecials字段是一个bitmap，指明哪些span有specials(finalizers or other)

zeroedBase记录了这个未被使用的第一个页的第一个byte，用于决定allocation是否需要be zeroed（问问ai吧。）




# 疑问

## 清除Span并free Object
1.mspan因新的分配而被清除，返回mcache以满足分配（还没太看懂，原文是If the mspan is being swept in response to allocation, it  is returned to the mcache to satisfy the allocation.）
2.如果mspan上仍然有object分配，则将其放在mcentral
3.如果msapn都空闲，mspan的pages可以返回mheap，并且mspan标记为dead

## (小对象扫描的Noscan\Noheaer 有什么区别呢？)

（为什么大对象需要在清理内存memclrNoHeapPointersChunked时要考虑抢占，为什么小对象就不要考虑被抢占的问题呢？）

为什么小对象没有类似的清理span逻辑呢？

## mem.go文件

